Table[][] allProvinceData; // 2D noemen
int[][][] allValues;      // [dataset][province][dataPoint]
int currentDataset = 0;

String[][] allProvinceFiles = {
  {"Antwerpen_TOT_IN.csv", "WestVlaanderen_TOT_IN.csv", "OostVlaanderen_TOT_IN.csv", "Limburg_TOT_IN.csv",
    "VlaamsBrabant_TOT_IN.csv", "Brussel_TOT_IN.csv", "luxemburg_TOT_IN.csv", "namen_TOT_IN.csv",
  "Hainaut_TOT_IN.csv", "Liege_TOT_IN.csv", "BrabantWallon_TOT_IN.csv"},
  {"antwerpen_TOT_ICU.csv", "westVlaanderen_TOT_ICU.csv", "oostVlaanderen_TOT_ICU.csv", "limburg_TOT_ICU.csv",
    "vlaamsBrabant_TOT_ICU.csv", "brussel_TOT_ICU.csv", "luxemburg_TOT_ICU.csv", "namen_TOT_ICU.csv", "hainaut_TOT_ICU.csv", "liege_TOT_ICU.csv",
  "brabantWallon_TOT_ICU.csv"},
  {"antwerpen_NEW_IN.csv", "westVlaanderen_NEW_IN.csv", "oostVlaanderen_NEW_IN.csv", "limburg_NEW_IN.csv",
    "vlaamsBrabant_NEW_IN.csv", "brussel_NEW_IN.csv", "luxemburg_NEW_IN.csv", "namen_NEW_IN.csv", "hainaut_NEW_IN.csv", "liege_NEW_IN.csv",
  "brabantWallon_NEW_IN.csv"},
  {"antwerpen_NEW_ICU.csv", "westVlaanderen_NEW_ICU.csv", "oostVlaanderen_NEW_ICU.csv", "limburg_NEW_ICU.csv",
    "vlaamsBrabant_NEW_ICU.csv", "brussel_NEW_ICU.csv", "luxemburg_NEW_ICU.csv", "namen_NEW_ICU.csv", "hainaut_NEW_ICU.csv", "liege_NEW_ICU.csv",
  "brabantWallon_NEW_ICU.csv"},
  {"antwerpen_TOT_RESP.csv", "westVlaanderen_TOT_RESP.csv", "oostVlaanderen_TOT_RESP.csv", "limburg_TOT_RESP.csv",
    "vlaamsBrabant_TOT_RESP.csv", "brussel_TOT_RESP.csv", "luxemburg_TOT_RESP.csv", "namen_TOT_RESP.csv", "hainaut_TOT_RESP.csv", "liege_TOT_RESP.csv",
  "brabantWallon_TOT_RESP.csv"},
  {"antwerpen_TOT_ECMO.csv", "westVlaanderen_TOT_ECMO.csv", "oostVlaanderen_TOT_ECMO.csv", "limburg_TOT_ECMO.csv",
    "vlaamsBrabant_TOT_ECMO.csv", "brussel_TOT_ECMO.csv", "luxemburg_TOT_ECMO.csv", "namen_TOT_ECMO.csv", "hainaut_TOT_ECMO.csv", "liege_TOT_ECMO.csv",
  "brabantWallon_TOT_ECMO.csv"},
  { "Antwerpen_NR_REP.csv", "WestVlaanderen_NR_REP.csv",  "OostVlaanderen_NR_REP.csv", "Limburg_NR_REP.csv", "VlaamsBrabant_NR_REP.csv", "Brussels_NR_REP.csv",
  "Luxembourg_NR_REP.csv", "Namur_NR_REP.csv", "Hainaut_NR_REP.csv","Li√®ge_NR_REP.csv", "BrabantWallon_NR_REP.csv"}
};

String[] datasettitels = {
  "Totaal opnames",
  "Totaal ICU opnames",
  "Nieuwe opnames",
  "Nieuwe ICU opnames",
  "Totaal beademing",
  "Totaal ECMO",
  "Aantal ziekenhuizen"
}; //voor titel


float translateX = 150;
float translateY = 50;
float cellWidth, cellHeight;
int dataPoints = 40;
int provinces = 11;
int numDatasets = 7;

void setup() {
  size(1500, 600);
  //noStroke();

  // Initialize arrays with correct dimensions
  allProvinceData = new Table[numDatasets][provinces];
  allValues = new int[numDatasets][provinces][dataPoints];


  // datasets laden
  for (int d = 0; d < numDatasets; d++) {
    for (int i = 0; i < provinces; i++) {
      // Skip if no file defined for this dataset/province
      if (allProvinceFiles[d].length > i && allProvinceFiles[d][i] != null) {
        allProvinceData[d][i] = loadTable(allProvinceFiles[d][i]);

        // Error
        if (allProvinceData[d][i] == null) {
          println("ERROR: Could not load " + allProvinceFiles[d][i]);
          exit();
        }

        // Store values
        for (int j = 0; j < dataPoints; j++) {
          if (j < allProvinceData[d][i].getRowCount()) {
            allValues[d][i][j] = allProvinceData[d][i].getInt(j, 0);
          }
        }
      }
    }
  }

  // Calculate cell dimensions
  cellWidth = (width - 200) / dataPoints;
  cellHeight = (height - 150) / provinces; //kleiner maken om ruimte te creeeren voor assen en legenda
}

void draw() {
  background(255);

  //zorgen dat de titel niet getranslate wordt
  fill(0);
  textAlign(LEFT, TOP);
  textSize(20);
  text("Dataset: " + (currentDataset + 1) + " - " + datasettitels[currentDataset], 10, 10);


  translate(translateX, translateY); //ruimte laten voor assen (ook nog voor legenda?)

  // Find maximum value in CURRENT dataset
  int maxVal = 0;
  for (int i = 0; i < provinces; i++) {
    for (int j = 0; j < dataPoints; j++) {
      if (allValues[currentDataset][i][j] > maxVal) {
        maxVal = allValues[currentDataset][i][j];
      }
    }
  }
//minimum vinden
  int minVal = 0;
  for (int i = 0; i < provinces; i++) {
    for (int j = 0; j < dataPoints; j++) {
      if (allValues[currentDataset][i][j] < minVal) {
        minVal = allValues[currentDataset][i][j];
      }
    }
  }


  // Draw heatmap for current dataset
  stroke(0);
  for (int i = 0; i < provinces; i++) {
    for (int j = 0; j < dataPoints; j++) {

      color minColor = color(0, 180,0 ); // green deze kleuren duidelijker wat goed en slecht is?
      color midcolor = color(255,255,0);//yellow
      color maxColor = color(180, 0, 0); // Red
      if (allValues[currentDataset][i][j] < maxVal/2) {
        float interp = map(log(allValues[currentDataset][i][j]), 0, log(maxVal/2), 0, 1);
        fill(lerpColor(minColor, midcolor, interp));
      } else {
        float interp = map(log(allValues[currentDataset][i][j]), log(maxVal/2), log(maxVal), 0, 1);
        fill(lerpColor(midcolor, maxColor, interp));
      }
      rect(j * cellWidth, i * cellHeight, cellWidth, cellHeight);
    }
  }
  int middle = width/6;
  color c;
  for (int i = 0; i < width/3; i++) {
    if (i < middle) {
      float inter = map(i, 0, middle, 0, 1);
      c = lerpColor(color(0, 180, 0), color(255,255,0), inter);
    } else {
      float inter = map(i, middle, width/3, 0, 1);
      c = lerpColor(color(255,255,0), color(180, 0, 0), inter);
    }
    stroke(c);

    line(i, height-120, i, height-80);
  }

  fill(0);
  textAlign(LEFT);
  textSize(15);
  text(minVal, 0, height-65);
  
  textAlign(CENTER);
  text(maxVal/2, width/6, height-65);
  textAlign(RIGHT);
  text(maxVal, width/3, height-65);
  //functie van mousehover
  muis();
  //functie die assen maakt
  assen (cellHeight,cellWidth);
  
}
